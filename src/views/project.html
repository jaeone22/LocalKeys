<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>LocalKeys</title>
        <link rel="stylesheet" href="../styles/common.css" />
    </head>
    <body>
        <div class="container">
            <div class="page-header project-header">
                <div class="page-title">
                    <button class="back-btn" id="back-btn">
                        <span class="lk-icon lk-icon-arrow-left" aria-hidden="true"></span>
                    </button>
                    <span id="project-name">Project</span>
                </div>
                <div class="header-actions">
                    <button class="btn" id="add-secret-btn">Add Secret</button>
                    <button class="btn btn-secondary" id="import-btn">Import</button>
                    <button class="btn btn-secondary" id="export-btn">Export</button>
                </div>
            </div>

            <!-- 검색 바 -->
            <div class="search-bar">
                <input type="text" class="search-input" id="search-input" placeholder="Search secrets..." />
                <span class="search-icon lk-icon lk-icon-search" aria-hidden="true"></span>
            </div>

            <!-- 시크릿 목록 -->
            <div class="secrets-container" id="secrets-container">
                <div class="loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>

        <!-- 시크릿 추가 모달 -->
        <div id="add-secret-modal" class="modal-overlay hidden">
            <div class="modal">
                <div class="modal-header">
                    <h3 class="modal-title" id="add-modal-title">Add New Secret</h3>
                </div>
                <div class="modal-body">
                    <div class="input-group">
                        <label for="secret-key" id="label-secret-key">Key</label>
                        <input type="text" id="secret-key" placeholder="Enter secret key" autocomplete="off" />
                    </div>
                    <div class="input-group">
                        <label for="secret-value" id="label-secret-value">Value</label>
                        <input type="text" id="secret-value" placeholder="Enter secret value" autocomplete="off" />
                    </div>
                    <div class="input-group">
                        <label for="secret-expires" id="label-secret-expires">Expiration Date (Optional)</label>
                        <input type="date" id="secret-expires" />
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" id="cancel-add-secret">Cancel</button>
                    <button class="btn" id="confirm-add-secret">Add Secret</button>
                </div>
            </div>
        </div>

        <!-- 시크릿 편집 모달 -->
        <div id="edit-secret-modal" class="modal-overlay hidden">
            <div class="modal">
                <div class="modal-header">
                    <h3 class="modal-title" id="edit-modal-title">Edit Secret</h3>
                </div>
                <div class="modal-body">
                    <div class="input-group">
                        <label for="edit-secret-key" id="label-edit-key">Key</label>
                        <input type="text" id="edit-secret-key" placeholder="Enter secret key" autocomplete="off" />
                    </div>
                    <div class="input-group">
                        <label for="edit-secret-value" id="label-edit-value">Value</label>
                        <input type="text" id="edit-secret-value" placeholder="Enter secret value" autocomplete="off" />
                    </div>
                    <div class="input-group">
                        <label for="edit-secret-expires" id="label-edit-expires">Expiration Date (Optional)</label>
                        <input type="date" id="edit-secret-expires" />
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" id="cancel-edit-secret">Cancel</button>
                    <button class="btn" id="confirm-edit-secret">Save Changes</button>
                </div>
            </div>
        </div>

        <script src="../modules/i18n-helper.js"></script>
        <script src="../modules/notification.js"></script>
        <script>
            document.addEventListener("DOMContentLoaded", async function () {
                // 다국어 초기화
                await i18n.init();

                // UI 번역 적용
                document.getElementById("add-secret-btn").textContent = i18n.t("project.addSecret");
                document.getElementById("import-btn").textContent = i18n.t("project.importEnv");
                document.getElementById("export-btn").textContent = i18n.t("project.exportEnv");
                document.getElementById("search-input").placeholder = i18n.t("project.searchPlaceholder");
                document.getElementById("add-modal-title").textContent = i18n.t("project.addSecretModal.title");
                document.getElementById("label-secret-key").textContent = i18n.t("project.addSecretModal.keyLabel");
                document.getElementById("secret-key").placeholder = i18n.t("project.addSecretModal.keyPlaceholder");
                document.getElementById("label-secret-value").textContent = i18n.t("project.addSecretModal.valueLabel");
                document.getElementById("secret-value").placeholder = i18n.t("project.addSecretModal.valuePlaceholder");
                document.getElementById("label-secret-expires").textContent = i18n.t("project.addSecretModal.expiresLabel", "Expiration Date (Optional)");
                document.getElementById("cancel-add-secret").textContent = i18n.t("common.cancel");
                document.getElementById("confirm-add-secret").textContent = i18n.t("project.addSecretModal.add");
                document.getElementById("edit-modal-title").textContent = i18n.t("project.editSecretModal.title");
                document.getElementById("label-edit-key").textContent = i18n.t("project.editSecretModal.keyLabel");
                document.getElementById("label-edit-value").textContent = i18n.t("project.editSecretModal.valueLabel");
                document.getElementById("label-edit-expires").textContent = i18n.t("project.editSecretModal.expiresLabel", "Expiration Date (Optional)");
                document.getElementById("cancel-edit-secret").textContent = i18n.t("common.cancel");
                document.getElementById("confirm-edit-secret").textContent = i18n.t("project.editSecretModal.save");
                const projectNameEl = document.getElementById("project-name");
                const secretsContainer = document.getElementById("secrets-container");
                const searchInput = document.getElementById("search-input");
                const backBtn = document.getElementById("back-btn");
                const addSecretBtn = document.getElementById("add-secret-btn");
                const exportBtn = document.getElementById("export-btn");
                const importBtn = document.getElementById("import-btn");

                // 모달 요소
                const addSecretModal = document.getElementById("add-secret-modal");
                const editSecretModal = document.getElementById("edit-secret-modal");
                const secretKeyInput = document.getElementById("secret-key");
                const secretValueInput = document.getElementById("secret-value");
                const secretExpiresInput = document.getElementById("secret-expires");
                const editSecretKeyInput = document.getElementById("edit-secret-key");
                const editSecretValueInput = document.getElementById("edit-secret-value");
                const editSecretExpiresInput = document.getElementById("edit-secret-expires");
                const cancelAddSecret = document.getElementById("cancel-add-secret");
                const confirmAddSecret = document.getElementById("confirm-add-secret");
                const cancelEditSecret = document.getElementById("cancel-edit-secret");
                const confirmEditSecret = document.getElementById("confirm-edit-secret");

                let projectName = "";
                let secrets = {};
                let filteredSecrets = {};
                let editingKey = "";

                // URL에서 프로젝트 이름 가져오기
                function getProjectNameFromURL() {
                    const urlParams = new URLSearchParams(window.location.search);
                    return urlParams.get("name") || "";
                }

                // 시크릿 로드
                async function loadSecrets() {
                    try {
                        const result = await window.localkeys.secrets.getAll(projectName);

                        if (result.success) {
                            secrets = result.data;
                            filteredSecrets = secrets;
                            renderSecrets();
                        } else {
                            notificationManager.error(i18n.t("project.notifications.failedToLoad"));
                        }
                    } catch (error) {
                        notificationManager.error(i18n.t("project.notifications.failedToLoad"));
                    }
                }

                // UTC 날짜를 로컬 시간대로 변환
                function toLocalDate(utcDateString) {
                    if (!utcDateString) return null;
                    const utcDate = new Date(utcDateString);
                    // UTC 시간을 로컬 시간대로 변환
                    const localDate = new Date(utcDate.getTime() + utcDate.getTimezoneOffset() * 60000);
                    return localDate;
                }

                // 만료 여부 확인
                function isExpired(expiresAt) {
                    if (!expiresAt) return false;
                    const now = new Date();
                    const expDate = toLocalDate(expiresAt);
                    return expDate < now;
                }

                // 만료 임박 여부 확인 (7일 이내)
                function isExpiringSoon(expiresAt) {
                    if (!expiresAt) return false;
                    const now = new Date();
                    const expDate = toLocalDate(expiresAt);
                    const hoursUntilExpiry = Math.ceil((expDate - now) / (1000 * 60 * 60));
                    return hoursUntilExpiry >= 0 && hoursUntilExpiry <= 7 * 24;
                }

                function createSecretRow(key, secret) {
                    const value = secret.value;
                    const expiresAt = secret.expiresAt;
                    const expired = isExpired(expiresAt);
                    const expiringSoon = isExpiringSoon(expiresAt);

                    const item = document.createElement("div");
                    item.className = "secret-item" + (expired ? " expired" : "") + (expiringSoon && !expired ? " expiring-soon" : "");

                    const header = document.createElement("div");
                    header.className = "secret-header";

                    const keyDiv = document.createElement("div");
                    keyDiv.className = "secret-key";
                    keyDiv.textContent = key;

                    const actionsDiv = document.createElement("div");
                    actionsDiv.className = "secret-actions";

                    const toggleBtn = document.createElement("button");
                    toggleBtn.className = "toggle-visibility";
                    const visibilityIcon = document.createElement("span");
                    visibilityIcon.className = "lk-icon lk-icon-eye";
                    visibilityIcon.setAttribute("aria-hidden", "true");
                    toggleBtn.appendChild(visibilityIcon);
                    toggleBtn.onclick = () => toggleVisibility(key, toggleBtn);

                    const editBtn = document.createElement("button");
                    editBtn.className = "btn btn-secondary";
                    editBtn.textContent = i18n.t("project.edit");
                    editBtn.onclick = () => editSecret(key);

                    const dropdownDiv = document.createElement("div");
                    dropdownDiv.className = "dropdown";

                    const dropdownBtn = document.createElement("button");
                    dropdownBtn.className = "btn btn-secondary dropdown-toggle";
                    const ellipsisIcon = document.createElement("span");
                    ellipsisIcon.className = "lk-icon lk-icon-ellipsis";
                    ellipsisIcon.setAttribute("aria-hidden", "true");
                    dropdownBtn.appendChild(ellipsisIcon);
                    dropdownBtn.onclick = (e) => {
                        e.stopPropagation();
                        toggleDropdown(key);
                    };

                    const dropdownMenu = document.createElement("div");
                    dropdownMenu.className = "dropdown-menu hidden";
                    dropdownMenu.id = `dropdown-${key}`;

                    const deleteBtn = document.createElement("button");
                    deleteBtn.className = "dropdown-item dropdown-item-danger";
                    deleteBtn.textContent = i18n.t("project.deleteSecret");
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteSecret(key);
                    };

                    dropdownMenu.appendChild(deleteBtn);
                    dropdownDiv.appendChild(dropdownBtn);
                    dropdownDiv.appendChild(dropdownMenu);
                    actionsDiv.appendChild(toggleBtn);
                    actionsDiv.appendChild(editBtn);
                    actionsDiv.appendChild(dropdownDiv);
                    header.appendChild(keyDiv);
                    header.appendChild(actionsDiv);

                    const valueDiv = document.createElement("div");
                    valueDiv.className = "secret-value masked";
                    valueDiv.id = `value-${key}`;
                    valueDiv.textContent = value;

                    item.appendChild(header);
                    item.appendChild(valueDiv);

                    // 만료일 표시
                    if (expiresAt) {
                        const expiresDiv = document.createElement("div");
                        expiresDiv.className = "secret-expires" + (expired ? " expired" : "") + (expiringSoon && !expired ? " expiring-soon" : "");

                        const expDate = toLocalDate(expiresAt);
                        const formattedDate = expDate.toLocaleDateString();
                        const now = new Date();
                        const hoursLeft = Math.ceil((expDate - now) / (1000 * 60 * 60));
                        const daysLeft = Math.ceil(hoursLeft / 24);

                        if (expired) {
                            expiresDiv.textContent = i18n.t("project.expiration.expiredOn", { date: formattedDate }, `Expired on ${formattedDate}`);
                        } else if (expiringSoon) {
                            // 3일~7일 남았을 때: 일수로 표시
                            if (daysLeft >= 3) {
                                if (daysLeft === 1) {
                                    expiresDiv.textContent = i18n.t("project.expiration.expiresInDays", { count: daysLeft, date: formattedDate }, `${daysLeft} day left (${formattedDate})`);
                                } else {
                                    expiresDiv.textContent = i18n.t("project.expiration.expiresInDaysPlural", { count: daysLeft, date: formattedDate }, `${daysLeft} days left (${formattedDate})`);
                                }
                            }
                            // 2일~1일 남았을 때: 시간으로 표시
                            else {
                                expiresDiv.textContent = i18n.t("project.expiration.expiresInHours", { count: hoursLeft, date: formattedDate }, `${hoursLeft} hours left (${formattedDate})`);
                            }
                        } else {
                            expiresDiv.textContent = i18n.t("project.expiration.expiresOn", { date: formattedDate }, `Expires on ${formattedDate}`);
                        }

                        item.appendChild(expiresDiv);
                    }

                    return item;
                }

                function createEmptyStateElement() {
                    const emptyState = document.createElement("div");
                    emptyState.className = "empty-state";

                    const icon = document.createElement("div");
                    icon.className = "empty-state-icon lk-icon lk-icon-key lk-icon-xl";
                    icon.setAttribute("aria-hidden", "true");

                    const title = document.createElement("div");
                    title.className = "empty-state-title";
                    title.textContent = i18n.t("project.emptyState.title");

                    const description = document.createElement("div");
                    description.className = "empty-state-description";
                    description.textContent = Object.keys(secrets).length === 0 ? i18n.t("project.emptyState.descriptionEmpty") : i18n.t("project.emptyState.descriptionSearch");

                    emptyState.appendChild(icon);
                    emptyState.appendChild(title);
                    emptyState.appendChild(description);

                    if (Object.keys(secrets).length === 0) {
                        const addBtn = document.createElement("button");
                        addBtn.className = "btn";
                        addBtn.textContent = i18n.t("project.addSecret");
                        addBtn.onclick = showAddSecretModal;
                        emptyState.appendChild(addBtn);
                    }
                    return emptyState;
                }

                // 시크릿 렌더링
                function renderSecrets() {
                    secretsContainer.innerHTML = ""; // Clear existing content
                    const secretKeys = Object.keys(filteredSecrets);

                    if (secretKeys.length === 0) {
                        secretsContainer.appendChild(createEmptyStateElement());
                        return;
                    }

                    const fragment = document.createDocumentFragment();
                    secretKeys.forEach((key) => {
                        fragment.appendChild(createSecretRow(key, filteredSecrets[key]));
                    });
                    secretsContainer.appendChild(fragment);
                }

                // 시크릿 가시성 토글
                function toggleVisibility(key, toggleBtn) {
                    const valueEl = document.getElementById(`value-${key}`);
                    valueEl.classList.toggle("masked");
                    if (!toggleBtn) return;
                    const iconEl = toggleBtn.querySelector(".lk-icon");
                    if (!iconEl) return;
                    const isMasked = valueEl.classList.contains("masked");
                    iconEl.classList.remove("lk-icon-eye", "lk-icon-eye-off");
                    iconEl.classList.add(isMasked ? "lk-icon-eye" : "lk-icon-eye-off");
                }

                // 시크릿 편집
                function editSecret(key) {
                    showEditSecretModal(key, secrets[key]);
                }

                // 시크릿 삭제
                async function deleteSecret(key) {
                    if (!confirm(i18n.t("project.deleteConfirm", { key: key }))) {
                        return;
                    }

                    try {
                        const result = await window.localkeys.secrets.delete(projectName, key);

                        if (result.success) {
                            await loadSecrets();
                            notificationManager.success(i18n.t("project.notifications.secretDeleted", { key: key }));
                        } else {
                            notificationManager.error(i18n.t("project.notifications.failedToDelete"));
                        }
                    } catch (error) {
                        notificationManager.error(i18n.t("project.notifications.failedToDelete"));
                    }
                }

                // 시크릿 추가 모달 표시
                function showAddSecretModal() {
                    addSecretModal.classList.remove("hidden");
                    secretKeyInput.value = "";
                    secretValueInput.value = "";
                    secretExpiresInput.value = "";

                    // 다음 프레임에서 애니메이션 시작
                    requestAnimationFrame(() => {
                        addSecretModal.classList.add("show");
                    });

                    secretKeyInput.focus();
                }

                // 시크릿 추가 모달 숨기기
                function hideAddSecretModal() {
                    addSecretModal.classList.remove("show");
                    addSecretModal.classList.add("closing");

                    // 애니메이션 완료 후 모달 완전히 숨기기
                    setTimeout(() => {
                        addSecretModal.classList.add("hidden");
                        addSecretModal.classList.remove("closing");
                    }, 250);
                }

                // 시크릿 편집 모달 표시
                function showEditSecretModal(key, secret) {
                    editSecretModal.classList.remove("hidden");
                    editSecretKeyInput.value = key;
                    editSecretValueInput.value = secret.value;
                    editSecretExpiresInput.value = secret.expiresAt || "";
                    editingKey = key;

                    // 다음 프레임에서 애니메이션 시작
                    requestAnimationFrame(() => {
                        editSecretModal.classList.add("show");
                    });

                    editSecretKeyInput.focus();
                }

                // 시크릿 편집 모달 숨기기
                function hideEditSecretModal() {
                    editSecretModal.classList.remove("show");
                    editSecretModal.classList.add("closing");

                    // 애니메이션 완료 후 모달 완전히 숨기기
                    setTimeout(() => {
                        editSecretModal.classList.add("hidden");
                        editSecretModal.classList.remove("closing");
                    }, 250);

                    editingKey = "";
                }

                // 시크릿 추가
                async function addSecret() {
                    const key = secretKeyInput.value.trim();
                    const value = secretValueInput.value;
                    const expiresAt = secretExpiresInput.value || null;

                    if (!key) {
                        notificationManager.error(i18n.t("project.notifications.enterKey"));
                        return;
                    }

                    if (secrets.hasOwnProperty(key)) {
                        notificationManager.error(i18n.t("project.notifications.keyExists"));
                        return;
                    }

                    try {
                        const result = await window.localkeys.secrets.set(projectName, key, value, expiresAt);

                        if (result.success) {
                            hideAddSecretModal();
                            await loadSecrets();
                            notificationManager.success(i18n.t("project.notifications.secretAdded", { key: key }));
                        } else {
                            notificationManager.error(i18n.t("project.notifications.failedToAdd"));
                        }
                    } catch (error) {
                        notificationManager.error(i18n.t("project.notifications.failedToAdd"));
                    }
                }

                // 시크릿 편집 저장
                async function saveSecret() {
                    const key = editSecretKeyInput.value.trim();
                    const value = editSecretValueInput.value;
                    const expiresAt = editSecretExpiresInput.value || null;

                    if (!key) {
                        notificationManager.error(i18n.t("project.notifications.enterKey"));
                        return;
                    }

                    // 키가 변경된 경우
                    if (key !== editingKey && secrets.hasOwnProperty(key)) {
                        notificationManager.error(i18n.t("project.notifications.keyExists"));
                        return;
                    }

                    try {
                        // 키가 변경된 경우 기존 키 삭제 후 새 키로 추가
                        if (key !== editingKey) {
                            await window.localkeys.secrets.delete(projectName, editingKey);
                        }

                        const result = await window.localkeys.secrets.set(projectName, key, value, expiresAt);

                        if (result.success) {
                            hideEditSecretModal();
                            await loadSecrets();
                            notificationManager.success(i18n.t("project.notifications.secretSaved", { key: key }));
                        }
                    } catch (error) {
                        notificationManager.error(i18n.t("project.notifications.failedToSave"));
                    }
                }

                // .env 파일로 내보내기
                async function exportAsEnv() {
                    try {
                        const result = await window.localkeys.secrets.export(projectName);

                        if (result.success) {
                            notificationManager.success(i18n.t("project.notifications.exported", { path: result.path }));
                        }
                    } catch (error) {
                        notificationManager.error(i18n.t("project.notifications.failedToExport"));
                    }
                }

                // .env 파일 불러오기
                async function importEnv() {
                    try {
                        const result = await window.localkeys.secrets.import(projectName);

                        if (result.success) {
                            await loadSecrets();
                            notificationManager.success(i18n.t("project.notifications.imported", { count: result.count }));
                        } else if (result.error && result.error !== "Import cancelled") {
                            notificationManager.error(i18n.t("project.notifications.failedToImport"));
                        }
                    } catch (error) {
                        notificationManager.error(i18n.t("project.notifications.failedToImport"));
                    }
                }

                // 검색
                function searchSecrets() {
                    const query = searchInput.value.toLowerCase().trim();

                    if (!query) {
                        filteredSecrets = secrets;
                    } else {
                        filteredSecrets = {};
                        Object.keys(secrets).forEach((key) => {
                            if (key.toLowerCase().includes(query)) {
                                filteredSecrets[key] = secrets[key];
                            }
                        });
                    }

                    renderSecrets();
                }

                // 이벤트 리스너
                searchInput.addEventListener("input", searchSecrets);
                backBtn.addEventListener("click", function () {
                    window.location.href = "dashboard.html";
                });
                addSecretBtn.addEventListener("click", showAddSecretModal);
                exportBtn.addEventListener("click", exportAsEnv);
                importBtn.addEventListener("click", importEnv);

                cancelAddSecret.addEventListener("click", hideAddSecretModal);
                confirmAddSecret.addEventListener("click", addSecret);
                cancelEditSecret.addEventListener("click", hideEditSecretModal);
                confirmEditSecret.addEventListener("click", saveSecret);

                secretKeyInput.addEventListener("keypress", function (e) {
                    if (e.key === "Enter") {
                        secretValueInput.focus();
                    }
                });

                secretValueInput.addEventListener("keypress", function (e) {
                    if (e.key === "Enter") {
                        addSecret();
                    }
                });

                editSecretKeyInput.addEventListener("keypress", function (e) {
                    if (e.key === "Enter") {
                        editSecretValueInput.focus();
                    }
                });

                editSecretValueInput.addEventListener("keypress", function (e) {
                    if (e.key === "Enter") {
                        saveSecret();
                    }
                });

                // 모달 외부 클릭 감지를 위한 변수
                let mouseDownTarget = null;

                // 마우스 다운 이벤트 추적
                document.addEventListener("mousedown", function (e) {
                    mouseDownTarget = e.target;
                });

                addSecretModal.addEventListener("click", function (e) {
                    // 클릭 시작과 끝 모두 모달 오버레이인 경우에만 닫기
                    if (mouseDownTarget === addSecretModal && e.target === addSecretModal) {
                        hideAddSecretModal();
                    }
                });

                editSecretModal.addEventListener("click", function (e) {
                    // 클릭 시작과 끝 모두 모달 오버레이인 경우에만 닫기
                    if (mouseDownTarget === editSecretModal && e.target === editSecretModal) {
                        hideEditSecretModal();
                    }
                });

                // 마우스 업 이벤트 추적 - 클릭 해제도 밖에서 해야 함
                document.addEventListener("mouseup", function (e) {
                    // 클릭 시작이 모달 오버레이였지만 클릭 해제가 모달 외부인 경우 모달 닫기
                    if ((mouseDownTarget === addSecretModal && e.target !== addSecretModal) || (mouseDownTarget === editSecretModal && e.target !== editSecretModal)) {
                        mouseDownTarget = null; // 초기화
                        return;
                    }
                });

                // 드롭다운 토글 함수
                function toggleDropdown(key) {
                    const dropdown = document.getElementById(`dropdown-${key}`);
                    const allDropdowns = document.querySelectorAll(".dropdown-menu");

                    // 다른 드롭다운 모두 닫기
                    allDropdowns.forEach((d) => {
                        if (d !== dropdown) {
                            d.classList.add("hidden");
                        }
                    });

                    // 현재 드롭다운 토글
                    dropdown.classList.toggle("hidden");
                }

                // 외부 클릭 시 드롭다운 닫기
                document.addEventListener("click", function (e) {
                    if (!e.target.closest(".dropdown")) {
                        const allDropdowns = document.querySelectorAll(".dropdown-menu");
                        allDropdowns.forEach((d) => d.classList.add("hidden"));
                    }
                });

                // 자동 새로고침 설정 (5초마다)
                const autoRefreshInterval = setInterval(async () => {
                    if (document.visibilityState === "visible") {
                        await loadSecrets();
                    }
                }, 5000);

                // 페이지가 보이지 않을 때는 자동 새로고침 중지
                document.addEventListener("visibilitychange", () => {
                    if (document.visibilityState === "hidden") {
                        clearInterval(autoRefreshInterval);
                    }
                });

                // 초기화
                projectName = getProjectNameFromURL();
                if (projectName) {
                    projectNameEl.textContent = projectName;
                    loadSecrets();
                } else {
                    notificationManager.error(i18n.t("project.notifications.noProject"));
                    setTimeout(() => {
                        window.location.href = "dashboard.html";
                    }, 2000);
                }
            });
        </script>
    </body>
</html>
